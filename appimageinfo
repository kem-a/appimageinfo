#!/bin/bash

# Check if an AppImage file is provided
if [ -z "$1" ]; then
    echo "Usage: $0 <appimage-file>"
    exit 1
fi

APPIMAGE_FILE="$1"

# Add './' prefix if the file is in the current directory and does not already start with './'
if [[ "$APPIMAGE_FILE" != /* && "$APPIMAGE_FILE" != ./* ]]; then
    APPIMAGE_FILE="./$APPIMAGE_FILE"
fi

# Check if the file exists
if [ ! -f "$APPIMAGE_FILE" ]; then
    echo "Error: File '$APPIMAGE_FILE' not found!"
    exit 1
fi

echo "Analyzing AppImage: $APPIMAGE_FILE"

# Resolve the directory where this script lives (for bundled tools)
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Detect filesystem type: SquashFS ('hsqs') or DwarFS ('DWARFS')
FS_TYPE=""
OFFSET=""

# Check for SquashFS magic bytes
SQFS_OFFSETS=$(grep -aob 'hsqs' "$APPIMAGE_FILE" 2>/dev/null | cut -d: -f1)
if [ -n "$SQFS_OFFSETS" ]; then
    TMPCHUNK=$(mktemp)
    for candidate in $(echo "$SQFS_OFFSETS" | sort -rn); do
        dd if="$APPIMAGE_FILE" bs=1 skip="$candidate" count=512 of="$TMPCHUNK" 2>/dev/null
        if file "$TMPCHUNK" | grep -qi 'squashfs.*version 4'; then
            OFFSET="$candidate"
            FS_TYPE="squashfs"
            break
        fi
    done
    rm -f "$TMPCHUNK"
fi

# If no SquashFS found, check for DwarFS
if [ -z "$FS_TYPE" ]; then
    if grep -aq 'DWARFS' "$APPIMAGE_FILE" 2>/dev/null; then
        FS_TYPE="dwarfs"
    fi
fi

# Check if any filesystem was found
if [ -z "$FS_TYPE" ]; then
    echo "Error: No valid SquashFS or DwarFS filesystem found. Make sure the file is a valid AppImage."
    exit 1
fi

echo "Filesystem type: $FS_TYPE"
if [ -n "$OFFSET" ]; then
    echo "Filesystem offset: $OFFSET"
fi
echo "----------------------------------------"

if [ "$FS_TYPE" = "squashfs" ]; then
    # Use unsquashfs to show filesystem info
    unsquashfs -o "$OFFSET" -stat "$APPIMAGE_FILE" 2>&1 | grep -v "Parallel unsquashfs"
elif [ "$FS_TYPE" = "dwarfs" ]; then
    # Use dwarfsck to show filesystem info (auto-detects offset)
    DWARFSCK=""
    if command -v dwarfsck &>/dev/null; then
        DWARFSCK="dwarfsck"
    elif [ -x "$SCRIPT_DIR/dwarfsck" ]; then
        DWARFSCK="$SCRIPT_DIR/dwarfsck"
    else
        echo "Error: dwarfsck not found. Install dwarfs or place dwarfsck next to this script."
        exit 1
    fi
    "$DWARFSCK" -i "$APPIMAGE_FILE" -O auto 2>&1
fi

# Extract update information from .upd_info ELF section
echo "----------------------------------------"
SECTION_LINE=$(objdump -h "$APPIMAGE_FILE" 2>/dev/null | grep '\.upd_info')
if [ -n "$SECTION_LINE" ]; then
    UPD_SIZE=$((16#$(echo "$SECTION_LINE" | awk '{print $3}')))
    UPD_OFFSET=$((16#$(echo "$SECTION_LINE" | awk '{print $6}')))

    if [ "$UPD_SIZE" -gt 0 ] && [ "$UPD_OFFSET" -gt 0 ]; then
        UPD_INFO=$(dd if="$APPIMAGE_FILE" bs=1 skip="$UPD_OFFSET" count="$UPD_SIZE" 2>/dev/null | tr -d '\0')

        if [ -n "$UPD_INFO" ]; then
            UPDATE_TYPE=$(echo "$UPD_INFO" | cut -d'|' -f1)
            case "$UPDATE_TYPE" in
                zsync)
                    echo "Update type: zsync"
                    echo "Update URL: $(echo "$UPD_INFO" | cut -d'|' -f2-)"
                    ;;
                gh-releases-zsync)
                    echo "Update type: gh-releases-zsync"
                    echo "Update URL: $(echo "$UPD_INFO" | cut -d'|' -f2-)"
                    ;;
                bintray-zsync)
                    echo "Update type: bintray-zsync"
                    echo "Update URL: $(echo "$UPD_INFO" | cut -d'|' -f2-)"
                    ;;
                *)
                    echo "Update type: unknown"
                    echo "Update info: $UPD_INFO"
                    ;;
            esac
        else
            echo "zsync update info not found (section is empty)"
        fi
    else
        echo "zsync update info not found (invalid section)"
    fi
else
    echo "zsync update info not found (no .upd_info section)"
fi
